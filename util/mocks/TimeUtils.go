package mocks

import (
	time "time"

	"github.com/kuritaeiji/ec_backend/util"
	mock "github.com/stretchr/testify/mock"
)

// TimeUtils is an autogenerated mock type for the TimeUtils type
type TimeUtils struct {
	mock.Mock
	timeUtils util.TimeUtils
}

// DateJP provides a mock function with given fields: year, month, day
func (_m *TimeUtils) DateJP(year int, month time.Month, day int) time.Time {
	return _m.timeUtils.DateJP(year, month, day)
}

// NowJP provides a mock function with given fields:
func (_m *TimeUtils) NowJP() time.Time {
	ret := _m.Called()

	var r0 time.Time
	if rf, ok := ret.Get(0).(func() time.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	return r0
}

// DateToJP provides a mock function with given fields: t
func (_m *TimeUtils) DateToJP(t time.Time) time.Time {
	return _m.timeUtils.DateToJP(t)
}

// DateToUTC provides a mock function with given fields: t
func (_m *TimeUtils) DateToUTC(t time.Time) time.Time {
	return _m.timeUtils.DateToUTC(t)
}

// TimeToJP provides a mock function with given fields: t
func (_m *TimeUtils) TimeToJP(t time.Time) time.Time {
	return _m.timeUtils.TimeToJP(t)
}

// TimeToUTC provides a mock function with given fields: t
func (_m *TimeUtils) TimeToUTC(t time.Time) time.Time {
	return _m.timeUtils.TimeToUTC(t)
}

// NewTimeUtils creates a new instance of TimeUtils. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTimeUtils(t interface {
	mock.TestingT
	Cleanup(func())
}, timeUtils util.TimeUtils) *TimeUtils {
	mock := &TimeUtils{timeUtils: timeUtils}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
